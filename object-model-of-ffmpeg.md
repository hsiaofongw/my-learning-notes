# FFMpeg 的对象模型

## 容器、流、封包和帧

为了应对多种情形下的多媒体处理任务，ffmpeg 代码库针对常见的多媒体数据类型作出了一些抽象。

![](container-and-streams.png)

一个多媒体文件，例如 somemovie.mp4，可以看作是一个 container（容器）。举例：

- “一路向北-周杰伦.mp3” 可以看作是一个 Container；
- “《疯狂动物城》.mkv” 可以看作是一个 Container；
- “花海.png" 可以看作是一个 Container；

容器的作用是容纳多个 streams（流），一个流可以用来存储：

- 一组运动的图片，这样的流也叫做视频流；
- 一段声音（音频流）；
- 一段字幕（字幕流）；
- 任何有可能随着时间变化的数据；

一个流的具象表示是：它是由 packets（封包）组成的，在 ffmpeg 代码库中，一个封包用一个 AVPacket 类型的结构体对象来表示，最基本地，每个 AVPacket 结构体对象至少有它所对应的流的 id（下标索引序号）。

我们说一个流可以看作是一系列的封包，那么来自多个流的封包如何存储到一个容器里边呢？实际上这属于容器格式的范畴，也就是说来自各个流的封包如何放进一个容器中，甚至封包在容器内如何表示和存储，都应该是由容器格式规范来规定的。但是一般来说，为了便于多媒体通过网络播放（也叫“串流”，对应英文单词 streaming），来自多个不同的流的封包一般是在容器中交错排列（如上图所示），假设有 a，b，c 三个流，那么来自这三个流的封包可能会以这样的方式交错 (interleave) 存放：a，b，c，a，b，c，……。

![](remuxing.png)

用来自一个或多个流的封包构建一个容器的过程，我们一般称之为 Muxing，从容器中提取（分离）出各个流的过程，叫做 Demuxing，这两个词似乎还没有特别好的翻译。

至此，我们应该已经可以理解，容器和流两者之间是略为「正交」的概念，比如说一个视频流，既可以存放在 movie.mp4 中，也可以存放在 movie.mkv 中，视频流本身是一摸一样的，而变化的只是容器格式。在 ffmpeg 中，有一个简单的命令可以进行这种转换：

```sh
ffmpeg -i movie.mp4 -c copy movie.mkv
```

当然，实际上流和容器并不完全是正交的，并不是任意的所谓”容器“都可以容纳任意类型、任意数量的流。

要对多媒体流进行播放，光从容器中提取出各路流，再从流中切割出一个个的封包还是不够，在 ffmpeg 代码库中，封包就其本身而言只具备关于多媒体信息的最小的知识，换句话说，假设你已拿到一个 AVPacket 结构体对象，你知道它属于哪个流，但是仍然不知道它的具体内容如何，一个封包有可能是来自一个视频流，但是要得到电影的一张图片，可能还需要更多的封包，一个封包也可能来自一个音频流，但是它可能不只包含一个声音波形样本（sample）。

ffmpeg 代码库提供流相应的函数实现从（一个或多个） `AVPacket` 结构体对象得到一个或多个 `AVFrame` 结构体对象，从封包得到帧的这个过程一般称之为「解码」（decoding），反之从帧到封包的这个过程一般称之为「编码」（encoding）。由于原始的像素矩阵需要占用大量的空间来存储、也需要大量的宽带来传输，所以视频（或图像）的编码往往还伴随着压缩，所谓压缩，就是找到一组信息的更加紧凑（更加不占用空间）的表示。压缩分为有损压缩和无损压缩，利用了无损压缩的编码方式也可称为无损编码（lossless encoding），利用来有损压缩的编码方式可称为有损编码（lossy encoding）。

有损压缩为了实现更高的压缩比，会以丢失一部分原始数据中的信息作为牺牲，一个像素阵列经过有损压缩（编码）后再解压缩（解码），则只能得到原始像素阵列的一个近似，一部分原始信息在压缩的过程中被永久的丢弃了。换句话说有损压缩某种程度上是不可逆的（对于被丢失的那部分信息来说）。相比而言，无损压缩是可逆的，理论上，一个像素阵列进行无损压缩，再进行解压缩后仍然能得到和原始数据一摸一样的结果。

在条件允许的前提下（例如在容器格式兼容的情况下），我们应当尽量避免对多媒体数据的重新编码，而是应该尽量地只在封包、流、容器的层面对多媒体数据进行操作。

## ffmpeg 命令行工具的面相对象抽象

如果我们说 ffmpeg 代码库处理的基本对象是容器、流、封包和帧，那么我们则可以说 ffmpeg 命令行工具处理的基本对象是 IO 上下文。一个 IO 上下文是一个计算机程序针对它所打开的文件（不管打开该文件的目的是为了读还是为了写）所要维护和簿记的状态变量，例如一个 IO 上下文可能包括这个文件名，已经读取了多少、已经写入了多少、读取缓冲区、写入缓冲区等。

- 当 ffmpeg 打开一个文件是为了从中读取数据，则可以认为相当于创建了一个用于输入的 IO 上下文；
- 当 ffmpeg 打开一个文件是为了写入它，也可以认为此时 ffmpeg 创建了一个 IO 上下文用以簿记和这个文件及文件写入有关的状态；
- 一个 TCP 连接在类 Unix 系统中用一个 socket 建模，socket 也可以看作是文件，ffmpeg 也可以向处理文件那样，处理远程的「文件」（通过 URL 的形式）。

ffmpeg 命令行工具的格式，就其最顶层而言，是这样的一个结构：

```
ffmpeg \
  [maybe global options] \
  -i <input1> -i <input2> ... -i <inputN> \
  <output1> <output2> ... <outputM>
```

我们至少可以看出它支持多个输入和多个输出，其实 N，M 都是正整数，且 N 未必等于 M。

ffmpeg 的命令行参数可分为全局参数，作用在某个流上的参数，作用在某个输入（IO 上下文）上的参数，作用在某个输出（IO 上下文）上的参数。

我们注意到 ffmpeg 命令行参数中每个 `<inputX>` 前面都都有一个 `-i` 参数，事实上如果一个参数它不能被识别为 global option，或者针对某个输入/输出/流的 option，则它会被认定为是一个 output，换句话说 ffmpeg 会尽力去识别每一个命令行参数（`char * argv[]`）并且尽力把它们中的每一个都挂靠到一个合适的地方，这个合适的地方可能是全局选项，可能是某个输入，可能是某个输出，也可能是某个具体的流，但是如果尽力而为后还是识别不了这个选项，才会把一个参数看作是输出路径。

因此要看明白一条 ffmpeg 命令，首先要知道它有哪些输入、哪些输出、哪些全局参数，然后细看哪些选项是针对哪个输出的，哪些选项是针对哪个输入的，哪些选项是针对具体的流的。
